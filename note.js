const db = require('../db'); class bookController{ async addToYourLikedBooksList(request,response){ try { const user_id = request.params.user_id; const book_id = request.params.book_id; const newFavoriteBook = await db.query(` INSERT INTO liked_books (user_id, book_id) VALUES ($1,$2) RETURNING * `, [user_id,book_id]); const newFavoriteBookFullInfo = await db.query(` select liked_books.id as record_id, liked_books.book_id,books.book_title,books.description as book_description, books.link_to_book_cover, liked_books.user_id , users.login as user_login, users.password as user_password, users.full_name as user_full_name, users.name as user_name, users.email as user_email, users.phone_number as user_phone_number, users.role_id as user_role_id from liked_books join users on users.user_id = liked_books.user_id join books on books.book_id = liked_books.book_id where users.user_id = $1 and books.book_id = $2 `, [user_id,book_id]); response.status(201).json(newFavoriteBookFullInfo.rows[0]) } catch (err) { response.status(500).json({message: `ошибка при добавлении книги в список любомое. ${err}`}) } } async deleteFromYourLikedBooks(request,response){ try { const {user_id, book_id} = request.params; const user_who_wants_delete_it = request.userProfileInfo ;if( user_who_wants_delete_it.user_id == user_id || user_who_wants_delete_it.role_id > 1 ){ const if_it_liked_in_the_first_place = await db.query(` select liked_books.id as record_id, liked_books.book_id,books.book_title,books.description as book_description, books.link_to_book_cover, books.how_many_books_left, liked_books.user_id , users.login as user_login, users.password as user_password, users.full_name as user_full_name, users.name as user_name, users.email as user_email, users.phone_number as user_phone_number, users.role_id as user_role_id from liked_books join users on users.user_id = liked_books.user_id join books on books.book_id = liked_books.book_id where users.user_id = $1 and books.book_id = $2 `,[user_id,book_id]); if(if_it_liked_in_the_first_place.rows.length === 0 ){ response.status(400).json({message: `пользователь под id: "${user_id}" не лайкал книги под id: "${book_id}". вы должно быть ошиблись`}); return } const deleted_from_favorite_books = await db.query(` DELETE FROM liked_books WHERE user_id = $1 AND book_id = $2 RETURNING * `,[user_id,book_id]); response.status(200).json({message: 'книга удалена из списка понравившихся', deleted_book: if_it_liked_in_the_first_place.rows[0] }) }else{ response.status(403).json({message: "вы не админ и не владелец аккаунта где удаляете любимую книгу, у вас нет прав"}) } } catch (err) { response.status(500).json({message: `ошибка при попытке удалить книгу из списка любимых у пользователя. ${err.message}`}) } } async getAllUsersReservedBooks (request, response){ try { const { user_id} = request.params; const allUsersReservedBooksEver = await db.query(` select users_books.record_id, users_books.book_id, users_books.recieve_before, users_books.if_received, users_books.if_returned, users_books.user_id, users.login as user_login, users.password as user_password, users.full_name as user_full_name, users.name as user_name, users.email as user_email, users.phone_number as user_phone_number, users.role_id as user_role_id, books.book_title,books.description as book_description, books.link_to_book_cover, books.how_many_books_left from users_books join users on users.user_id = users_books.user_id join books on books.book_id = users_books.book_id where users.user_id = $1 `,[user_id]);response.status(200).json(allUsersReservedBooksEver.rows ) } catch (err) { response.status(500).json({message: `ошибка при попытке получить все книги которые пользователь когда либо брал. ${err.message}`}) } } async getAllTheBooksTheUserStillHasntRecieved(request,response){ try { const {user_id} = request.params; const allTheBooksTheUserStillHasntRecieved = await db.query(` select users_books.record_id, users_books.book_id, users_books.recieve_before, users_books.if_received, users_books.if_returned, users_books.user_id, users.login as user_login, users.password as user_password, users.full_name as user_full_name, users.name as user_name, users.email as user_email, users.phone_number as user_phone_number, users.role_id as user_role_id, books.book_title,books.description as book_description, books.link_to_book_cover, books.how_many_books_left from users_books join users on users.user_id = users_books.user_id join books on books.book_id = users_books.book_id where users.user_id = $1 AND users_books.if_received = false `,[user_id]); response.status(200).json(allTheBooksTheUserStillHasntRecieved.rows) } catch (err) { response.status(500).json({message: `ошибка при попытке получить все книги которые пользователь когда либо забронировал НО ЕЩЕ НЕ ЗАБРАЛ из библиотеки. ${err.message}`}) } } async getAllTheBooksTheUserStillHasntReturned(request,response){ try { const {user_id} = request.params; const allTheBooksTheUserStillHasntReturned = await db.query(` select users_books.record_id, users_books.book_id, users_books.recieve_before, users_books.if_received, users_books.if_returned, users_books.user_id, users.login as user_login, users.password as user_password, users.full_name as user_full_name, users.name as user_name, users.email as user_email, users.phone_number as user_phone_number, users.role_id as user_role_id, books.book_title,books.description as book_description, books.link_to_book_cover, books.how_many_books_left from users_books join users on users.user_id = users_books.user_id join books on books.book_id = users_books.book_id where users.user_id = $1 and users_books.if_returned = false and users_books.if_received = true `,[user_id]); response.status(200).json(allTheBooksTheUserStillHasntReturned.rows) } catch (err) { response.status(500).json({message: `ошибка при попытке получить все книги которые пользователь когда либо брал НО ЕЩЕ НЕ ВЕРНУЛ назад. ${err.message}`}) } } async getAllUsersLikedBooks(request,response){ try { const user_id = request.params.user_id // придит как строка const user_who_wants_to_see = request.userProfileInfo // user_who_wants_to_see.user_id - приходит как число if( user_who_wants_to_see.user_id == user_id || user_who_wants_to_see.role_id > 1 ){ const allUsersLikedBooks = await db.query(` select liked_books.id as record_id, liked_books.book_id,books.book_title,books.description as book_description, books.link_to_book_cover, books.how_many_books_left, liked_books.user_id , users.login as user_login, users.password as user_password, users.full_name as user_full_name, users.name as user_name, users.email as user_email, users.phone_number as user_phone_number, users.role_id as user_role_id from liked_books join users on users.user_id = liked_books.user_id join books on books.book_id = liked_books.book_id where users.user_id = $1 `,[user_id]) response.json(allUsersLikedBooks.rows) }else{ response.status(403).json({message:'вы не админ и не владелец аккаунта. у вас нет прав к просмотру списка понравившихся книг другого пользователя'}) } } catch (err) { response.status(500).json({message: `ошибка при попытке получить все книги которые лайкал пользователь. ${err.message}`}) } } async getTheWritersOfABook(request,response){ try { const book_id = request.params.book_id const theWritersOfTheBook = await db.query(` select writers_books.record_id, writers_books.writer_id, writers.writer_full_name, writers.writer_birth_date, writers.writer_death_date, writers_books.book_id, books.book_title, books.description as book_description from writers_books join books on books.book_id = writers_books.book_id join writers on writers.writer_id = writers_books.writer_id where books.book_id = $1 `,[book_id]) response.status(200).json(theWritersOfTheBook.rows) } catch (err) { response.status(500).json({message: `ошибка при попытке получить всех автооров какой то определенной книги. ${err.message}`}) } } async getAllGenresAndItsBooks(request,response) { try { const allGenres = await db.query(`SELECT * FROM book_genres`) const allGenresBooks = await db.query(` select book_genres.genre_name, genres_books.genre_id, genres_books.book_id , books.book_title, books.description, books.link_to_book_cover, books.how_many_books_left from genres_books join books on books.book_id = genres_books.book_id join book_genres on book_genres.genre_id = genres_books.genre_id`) const allGenresBooksSortedOut = allGenres.rows allGenresBooksSortedOut.map((genre_element,index)=>{ genre_element.its_books = allGenresBooks.rows.filter((current_record,index)=>{ if (genre_element.genre_id === current_record.genre_id ) { return true } }) }) response.status(200).json(allGenresBooksSortedOut) } catch (err) { response.status(500).json({message: `ошибка при попытке получить все жанры и книги по жанрам ${err.message}`}) } } async cancelYourBookReservation(request, response){ try { const { record_id} = request.params const ifTheReservationExists = await db.query(` select users_books.record_id, users_books.book_id, users_books.recieve_before, users_books.if_received, users_books.if_returned, users_books.user_id, users.login as user_login, users.password as user_password, users.full_name as user_full_name, users.name as user_name, users.email as user_email, users.phone_number as user_phone_number, users.role_id as user_role_id, books.book_title,books.description as book_description, books.link_to_book_cover, books.how_many_books_left from users_books join users on users.user_id = users_books.user_id join books on books.book_id = users_books.book_id where users_books.record_id = $1 `,[record_id]) if(ifTheReservationExists.rows.length === 0 ){ response.status(404).json({message: `брони книги под record_id = " ${record_id} не существует"`}) return } const deleted_book_reservation = await db.query(` delete from users_books where record_id = $1 returning * `,[record_id]) //если бронь отменили значит прибавляем кол-во книги на 1 //! по хорошему можно после выполнения функции контроллера запустить миддлварэ на прибавление книги + 1 const book_id = ifTheReservationExists.rows[0].book_id const how_many_these_kinda_books_left = ifTheReservationExists.rows[0].how_many_books_left const updatedBooksQuantity = await db.query(` update books set how_many_books_left = $2 where book_id = $1 `,[book_id, +how_many_these_kinda_books_left + 1]) ifTheReservationExists.rows[0].how_many_books_left = +ifTheReservationExists.rows[0].how_many_books_left + 1 response.status(200).json({deleted_reservation: ifTheReservationExists.rows[0], message: 'бронь успешно удалена'}) } catch (err) { response.status(500).json({message: `ошибка при попытке аннулировать бронь на книгу. ${err.message}`}) } } async borrowBook(request,response){ try { const user_id = request.params.user_id const book_id = request.params.book_id const current_date = new Date() // current_date.getMonth()+2 (так как считает от 0 до 11 , +1 это приводим его к 1 до 12 . и еще +1 это даем месяц на то чтобы забрать книгу ) const reserveTheBook = await db.query(`INSERT INTO users_books (user_id, book_id,recieve_before, if_received, if_returned) values ($1,$2,$3,$4,$5 )`,[user_id,book_id,`${current_date.getFullYear()}-${current_date.getMonth()+2}-${current_date.getDate()}`,false,false]) //поскольку книгу забронировали, нужно уменьшить количество доступных книг ( уменьшаем количество доступных книг на одну ) const changedBook = await db.query(`UPDATE books SET how_many_books_left = $1 WHERE book_id = $2 RETURNING *`,[request.how_many_books_left - 1,book_id]) const allReservedBooks = await db.query(`select users_books.record_id, users_books.book_id, users_books.recieve_before, users_books.if_received, users_books.if_returned, users_books.user_id, users.login as user_login, users.password as user_password, users.full_name as user_full_name, users.name as user_name, users.email as user_email, users.phone_number as user_phone_number, users.role_id as user_role_id, books.book_title,books.description as book_description, books.link_to_book_cover, books.how_many_books_left from users_books join users on users.user_id = users_books.user_id join books on books.book_id = users_books.book_id `) const ourReservedBook = allReservedBooks.rows[allReservedBooks.rows.length - 1] response.status(201).json(ourReservedBook) } catch (err) { response.status(500).json({message: `ошибка при попытке позволить забронировать книгу . ${err.message}`}) } } } module.exports = new bookController()